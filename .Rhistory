( beta = as.numeric(sim_obj$beta) )
( exclude_from_imp_model = as.character( sim_obj$exclude_from_imp_model ) )
str(sim_obj)
# coefficient of interest for gold-standard model
if ( coef_of_interest == "(Intercept)" ){
coef_of_interest_gold = "(Intercept)"
} else {
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest_gold = paste(coef_of_interest, "1", sep = "")
}
# some methods don't make sense for certain combos of DAG and coef_of_interest
#@this happens when a variable needed for imputation model is also in the target law
#  later could deal with this by adding the variable back into dataset after imputation
if ( (p$dag_name == "1D" & coef_of_interest == "A") |
(p$dag_name == "1B" & coef_of_interest == "A") ) {
all.methods = all.methods[ !all.methods %in% c("MICE-ours", "Am-ours") ]
}
head(di_std)
colSums(is.na(di_std))
mean(is.na(di_std$B))
cor(du %>% select(A1,B1,C1))
imps_mice_std = mice( di_std,
maxit = p$imp_maxit,
m = p$imp_m,
printFlag = FALSE )
imps_mice_std$loggedEvents
# sanity check
imp1 = complete(imps_mice_std, 1)
cor(imp1)
lm(B~A,data=imp1)
lm(B1~A1,data=du)
# TEMP
cors = lapply( X = 1:m,
FUN = function(.m) cor(complete(imps1, .m) ) )
# TEMP
cors = lapply( X = 1:p$imp_m,
FUN = function(.m) cor(complete(imps1, .m) ) )
# TEMP
cors = lapply( X = 1:p$imp_m,
FUN = function(.m) cor(complete(imps_mice_std, .m) ) )
cors
# **compare to underlying data
cor(du %>% select(A1,B1,C1))
( mean_cor_imps = Reduce("+", cors) / length(cors) )
p$imp_maxit=200
imps_mice_std = mice( di_std,
maxit = p$imp_maxit,
m = p$imp_m,
printFlag = FALSE )
cors = lapply( X = 1:p$imp_m,
FUN = function(.m) cor(complete(imps_mice_std, .m) ) )
# **compare to underlying data
cor(du %>% select(A1,B1,C1))
( mean_cor_imps = Reduce("+", cors) / length(cors) )
x = complete.cases(du)
dim(x)
?complete.cases
x
sum(x)
sum( complete.cases(di_std) )
sum( complete.cases(di_std) ) / nrow(di_std)
source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
# because Sherlock 2.0 restores previous workspace
rm( list = ls() )
# are we running locally?
run.local = FALSE
#  run.local = TRUE
# should we set scen params interactively on cluster?
# *if you accidently set this to TRUE and run via sbatches on cluster,
#   they will all run the same scenario!
interactive.cluster.run = FALSE
# should lots of output be printed for each sim rep?
verbose = FALSE
# ~~ Packages -----------------------------------------------
toLoad = c("crayon",
"dplyr",
"foreach",
"doParallel",
"data.table",
"purrr",
"tidyr",
"tibble",
"testthat",
"Hmisc",
"stringr",
"mice",
"Amelia",
"sandwich")
if ( run.local == TRUE | interactive.cluster.run == TRUE ) toLoad = c(toLoad, "here")
# SET UP FOR CLUSTER OR LOCAL RUN ------------------------------
# ~~ Cluster Run ----------------------------------------
if (run.local == FALSE ) {
# load command line arguments
args = commandArgs(trailingOnly = TRUE)
cat("\n\n args received from sbatch file:", args)
jobname = args[1]
scen = args[2]  # this will be a number
# load packages with informative messages if one can't be installed
# **Common reason to get the "could not library" error: You did ml load R/XXX using an old version
any.failed = FALSE
for (pkg in toLoad) {
cat( paste("\nAbout to try loading package", pkg) )
tryCatch({
# eval below needed because library() will otherwise be confused
# https://www.mitchelloharawild.com/blog/loading-r-packages-in-a-loop/
eval( bquote( library( .(pkg) ) ) )
}, error = function(err) {
cat( paste("\n*** COULD NOT LOAD PACKAGE:", pkg) )
any.failed <<- TRUE
})
}
if ( any.failed == TRUE ) stop("Some packages couldn't be loaded. See outfile for details of which ones.")
# helper code
path = "/home/groups/manishad/IWN"
setwd(path)
source("helper_IWN.R")
# get scen parameters (made by genSbatch.R)
setwd(path)
scen.params = read.csv( "scen_params.csv" )
p <<- scen.params[ scen.params$scen == scen, ]
cat("\n\nHEAD OF ENTIRE SCEN.PARAMS:\n")
print(p)
# ~~*********** Set cluster sim reps ----------------
# simulation reps to run within this job
# **this need to match n.reps.in.doParallel in the genSbatch script
sim.reps = 50
# set the number of cores
registerDoParallel(cores=16)
}
# FOR LOCAL USE  ------------------------------
if ( run.local == TRUE ) {
lapply( toLoad,
require,
character.only = TRUE)
# helper fns
code.dir = here()
setwd(code.dir)
source("helper_IWN.R")
# for saving intermediate results
data.dir = str_replace( string = here(),
pattern = "Simulation code",
replacement = "Simulation results" )
# ~~ ********** Set Sim Params: Local Run -----------------------------
scen.params = tidyr::expand_grid(
#rep.methods = "gold ; CC ; MICE-std ; Am-std ; MICE-ours ; MICE-ours-pred ; Am-ours",
rep.methods = "MICE-std",
model = "OLS",
#coef_of_interest = c( "(Intercept)", "A"),  # "(Intercept)" or "A"
coef_of_interest = "A",
# as on cluster
imp_m = 50,
imp_maxit = 100,
N = c(1000),
# # for quicker sims
# imp_m = 5,
# imp_maxit = 5,
# N = c(100),
#dag_name = c( "1B", "1D", "1G", "1H" ),
dag_name = "1H"
)
# remove combos that aren't implemented
scen.params = scen.params %>% filter( !(dag_name %in% c("1G", "1H") &
coef_of_interest == "(Intercept)") )
start.at = 1  # scen name to start at
scen.params$scen = start.at:( nrow(scen.params) + start.at - 1 )
sim.reps = 1  # reps to run in this iterate
# set the number of local cores
registerDoParallel(cores=8)
scen = 1
# data.frame(scen.params %>% filter(scen.name == scen))
# just to avoid errors in doParallel script below
jobname = "job_1"
i = 1
}
# RUN SIMULATION ------------------------------
# mimic Sherlock structure
if (run.local == TRUE) ( scens_to_run = scen.params$scen )
if (run.local == FALSE) ( scens_to_run = scen )  # from sbatch
scen.params
run.local = TRUE
# should we set scen params interactively on cluster?
# *if you accidently set this to TRUE and run via sbatches on cluster,
#   they will all run the same scenario!
interactive.cluster.run = FALSE
# should lots of output be printed for each sim rep?
verbose = FALSE
# ~~ Packages -----------------------------------------------
toLoad = c("crayon",
"dplyr",
"foreach",
"doParallel",
"data.table",
"purrr",
"tidyr",
"tibble",
"testthat",
"Hmisc",
"stringr",
"mice",
"Amelia",
"sandwich")
if ( run.local == TRUE | interactive.cluster.run == TRUE ) toLoad = c(toLoad, "here")
# SET UP FOR CLUSTER OR LOCAL RUN ------------------------------
# ~~ Cluster Run ----------------------------------------
if (run.local == FALSE ) {
# load command line arguments
args = commandArgs(trailingOnly = TRUE)
cat("\n\n args received from sbatch file:", args)
jobname = args[1]
scen = args[2]  # this will be a number
# load packages with informative messages if one can't be installed
# **Common reason to get the "could not library" error: You did ml load R/XXX using an old version
any.failed = FALSE
for (pkg in toLoad) {
cat( paste("\nAbout to try loading package", pkg) )
tryCatch({
# eval below needed because library() will otherwise be confused
# https://www.mitchelloharawild.com/blog/loading-r-packages-in-a-loop/
eval( bquote( library( .(pkg) ) ) )
}, error = function(err) {
cat( paste("\n*** COULD NOT LOAD PACKAGE:", pkg) )
any.failed <<- TRUE
})
}
if ( any.failed == TRUE ) stop("Some packages couldn't be loaded. See outfile for details of which ones.")
# helper code
path = "/home/groups/manishad/IWN"
setwd(path)
source("helper_IWN.R")
# get scen parameters (made by genSbatch.R)
setwd(path)
scen.params = read.csv( "scen_params.csv" )
p <<- scen.params[ scen.params$scen == scen, ]
cat("\n\nHEAD OF ENTIRE SCEN.PARAMS:\n")
print(p)
# ~~*********** Set cluster sim reps ----------------
# simulation reps to run within this job
# **this need to match n.reps.in.doParallel in the genSbatch script
sim.reps = 50
# set the number of cores
registerDoParallel(cores=16)
}
# FOR LOCAL USE  ------------------------------
if ( run.local == TRUE ) {
lapply( toLoad,
require,
character.only = TRUE)
# helper fns
code.dir = here()
setwd(code.dir)
source("helper_IWN.R")
# for saving intermediate results
data.dir = str_replace( string = here(),
pattern = "Simulation code",
replacement = "Simulation results" )
# ~~ ********** Set Sim Params: Local Run -----------------------------
scen.params = tidyr::expand_grid(
#rep.methods = "gold ; CC ; MICE-std ; Am-std ; MICE-ours ; MICE-ours-pred ; Am-ours",
rep.methods = "MICE-std",
model = "OLS",
#coef_of_interest = c( "(Intercept)", "A"),  # "(Intercept)" or "A"
coef_of_interest = "A",
# as on cluster
imp_m = 50,
imp_maxit = 100,
N = c(1000),
# # for quicker sims
# imp_m = 5,
# imp_maxit = 5,
# N = c(100),
#dag_name = c( "1B", "1D", "1G", "1H" ),
dag_name = "1H"
)
# remove combos that aren't implemented
scen.params = scen.params %>% filter( !(dag_name %in% c("1G", "1H") &
coef_of_interest == "(Intercept)") )
start.at = 1  # scen name to start at
scen.params$scen = start.at:( nrow(scen.params) + start.at - 1 )
sim.reps = 1  # reps to run in this iterate
# set the number of local cores
registerDoParallel(cores=8)
scen = 1
# data.frame(scen.params %>% filter(scen.name == scen))
# just to avoid errors in doParallel script below
jobname = "job_1"
i = 1
}
# RUN SIMULATION ------------------------------
# only print info for first sim rep for visual clarity
if ( i == 1 ) cat("\n\n~~~~~~~~~~~~~~~~ BEGIN SIM REP", i, "~~~~~~~~~~~~~~~~")
# results for just this simulation rep
if ( exists("rep.res") ) suppressWarnings( rm(rep.res) )
# extract simulation params for this scenario (row)
# exclude the column with the scenario name itself (col)
if ( verbose == TRUE ) {
cat("\n\n scen variable:\n")
print(scen)
cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
coef_of_interest = p$coef_of_interest
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
( all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) ) )
debugSource("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
sim_obj = sim_data(.p = p)
cor(du %>% select(A1, B1, C1))
coef1 = 2  # as in 2023-08-21 sims, where MICE unexpected performed badly
#**IMPORTANT: this DAG has beta (below) estimated empirically.
# if any parameters below change, you'll need to re-estimate it.
du = du %>% rowwise() %>%
mutate( C1 = rnorm( n = 1,
mean = coef1*A1 ),
B1 = rnorm( n = 1,
# coef1 is the direct effect of A1
mean = coef1*C1 + coef1*A1 ),
RB = rbinom( n = 1,
prob = expit(1*C1),
size = 1 ),
A = A1,
B = ifelse(RB == 0, NA, B1),
C = C1)
cor(du %>% select(A1, B1, C1))
coef1 = 1
#coef1 = 2  # as in 2023-08-21 sims, where MICE unexpected performed badly
#**IMPORTANT: this DAG has beta (below) estimated empirically.
# if any parameters below change, you'll need to re-estimate it.
du = du %>% rowwise() %>%
mutate( C1 = rnorm( n = 1,
mean = coef1*A1 ),
B1 = rnorm( n = 1,
# coef1 is the direct effect of A1
mean = coef1*C1 + coef1*A1 ),
RB = rbinom( n = 1,
prob = expit(1*C1),
size = 1 ),
A = A1,
B = ifelse(RB == 0, NA, B1),
C = C1)
cor(du %>% select(A1, B1, C1))
coef1^2 + coef1
debugSource("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
p$dag_name="1G"
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
coef_of_interest = p$coef_of_interest
p$dag_name="1G"
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
( all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) ) )
# ~ Simulate Dataset ------------------------------
sim_obj = sim_data(.p = p)
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
( form_string = as.character( sim_obj$form_string ) )
( gold_form_string = as.character( sim_obj$gold_form_string ) )
( beta = as.numeric(sim_obj$beta) )
( exclude_from_imp_model = as.character( sim_obj$exclude_from_imp_model ) )
p$dag_name
sim_obj = sim_data(.p = p)
debugSource("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
sim_obj = sim_data(.p = p)
source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
p
sim_obj = sim_data(.p = p)
cor(du %>% select(A,B,C,D))
coef1 = 2
#**IMPORTANT: this DAG has beta (below) estimated empirically.
# if any parameters below change, you'll need to re-estimate it.
du = du %>% rowwise() %>%
mutate( A1 = rnorm( n = 1,
mean = coef1*U1 ),
D1 = rnorm( n = 1,
mean = coef1*U1 + coef1*U2 ),
B1 = rnorm( n = 1,
mean = coef1*A1 ),
C1 = rnorm( n = 1,
mean = coef1*B1 ),
RA = rbinom( n = 1,
prob = expit(1*C1 + 1*U2),
size = 1 ),
RB = rbinom( n = 1,
prob = 1, # NOT MISSING to avoid unblockable m-bd path
size = 1 ),
A = ifelse(RA == 0, NA, A1),
B = ifelse(RB == 0, NA, B1),
C = C1,
D = D1)
#cor(du %>% select(A,B,C,D))
cor(du %>% select(A,B,C,D))
coef1 = 1
#**IMPORTANT: this DAG has beta (below) estimated empirically.
# if any parameters below change, you'll need to re-estimate it.
du = du %>% rowwise() %>%
mutate( A1 = rnorm( n = 1,
mean = coef1*U1 ),
D1 = rnorm( n = 1,
mean = coef1*U1 + coef1*U2 ),
B1 = rnorm( n = 1,
mean = coef1*A1 ),
C1 = rnorm( n = 1,
mean = (coef1/2)*B1 ),
RA = rbinom( n = 1,
prob = expit(1*C1 + 1*U2),
size = 1 ),
RB = rbinom( n = 1,
prob = 1, # NOT MISSING to avoid unblockable m-bd path
size = 1 ),
A = ifelse(RA == 0, NA, A1),
B = ifelse(RB == 0, NA, B1),
C = C1,
D = D1)
cor(du %>% select(A,B,C,D))
p$N=50000
source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
sim_obj = sim_data(.p = p)
lm(B1~A1,data=du)
source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
p$dag_name="1B"
debugSource("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
sim_obj = sim_data(.p = p)
Ideas to understand DAG 1G:
•	In data generation, remove the path from A to Ra via B and C. Then the DAG will be a lot like 1B, so I expect standard imputation to break.
•	And presumably mice-ours-pred should also be fine, since B isn’t involved in target law?
cor(du %>% select(A1, B1, C1))
p$dag_name="1D"
sim_obj = sim_data(.p = p)
cor(du %>% select(A1,B1,C1))
p
p$dag_name = "1G"
# only print info for first sim rep for visual clarity
if ( i == 1 ) cat("\n\n~~~~~~~~~~~~~~~~ BEGIN SIM REP", i, "~~~~~~~~~~~~~~~~")
# results for just this simulation rep
if ( exists("rep.res") ) suppressWarnings( rm(rep.res) )
# extract simulation params for this scenario (row)
# exclude the column with the scenario name itself (col)
if ( verbose == TRUE ) {
cat("\n\n scen variable:\n")
print(scen)
cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
coef_of_interest = p$coef_of_interest
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
( all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) ) )
# ~ Simulate Dataset ------------------------------
sim_obj = sim_data(.p = p)
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
( form_string = as.character( sim_obj$form_string ) )
( gold_form_string = as.character( sim_obj$gold_form_string ) )
( beta = as.numeric(sim_obj$beta) )
( exclude_from_imp_model = as.character( sim_obj$exclude_from_imp_model ) )
imps_mice_std = mice( di_std,
maxit = p$imp_maxit,
m = p$imp_m,
method = "norm",
printFlag = FALSE )
imps_mice_std$method
path = "/home/groups/manishad/IWN/overall_stitched"
setwd(path)
fwrite(t, "temp_agg.csv")
?mice
s = data.frame( scen = c(1,1,1,1), beta = rep(NA,4), method = c("gold", "gold", "other", "other"), bhat = c(2,3,0,1) )
s
beta_emp = s %>% filter(method == "gold") %>%
group_by(scen) %>%
mutate(beta = meanNA(bhat))
beta_emp
# fill in beta using gold-standard
# s = data.frame( scen = c(1,1,1,1), beta = rep(NA,4), method = c("gold", "gold", "other", "other"), bhat = c(2,3,0,1) )  # test
beta_emp = s %>% filter(method == "gold") %>%
group_by(scen) %>%
summarise(beta = meanNA(bhat))
beta_emp
s2 = s
s2 %>% mutate( beta = ifelse( !is.na(beta),
beta,
beta_emp$beta[ beta_emp$scen == scen ] ) )
s2 %>% rowwise() %>%
mutate( beta = ifelse( !is.na(beta),
beta,
beta_emp$beta[ beta_emp$scen == scen ] ) )
# fill in beta using gold-standard
s = data.frame( scen = c(1,1,1,1,2,2,2,2),
beta = c( rep(NA,4), rep(1,4)),
method = rep( c("gold", "gold", "other", "other"), 2),
bhat = rep( c(2,3,0,1), 2 ) )  # test
s
beta_emp = s %>% filter(method == "gold") %>%
group_by(scen) %>%
summarise(beta = meanNA(bhat))
( beta_emp = s %>% filter(method == "gold") %>%
group_by(scen) %>%
summarise(beta = meanNA(bhat)) )
s2 = s
s2 %>% rowwise() %>%
mutate( beta = ifelse( !is.na(beta),
beta,
beta_emp$beta[ beta_emp$scen == scen ] ) )
