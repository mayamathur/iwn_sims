cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) )
# ~ Simulate Dataset ------------------------------
sim_obj = sim_data(.p = p)
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
( form_string = as.character( sim_obj$form_string ) )
( gold_form_string = as.character( sim_obj$gold_form_string ) )
( beta = as.numeric(sim_obj$beta) )
( coef_of_interest = as.character( sim_obj$coef_of_interest ) )
# ~ Make Imputed Data ------------------------------
# details of how mice() implements pmm:
# ?mice.impute.pmm
if ( "MICE-std" %in% all.methods ) {
imps_mice_std = mice( di_std,
maxit = p$imp_maxit,
m = p$imp_m )
# sanity check
imp1 = complete(imps_mice_std, 1)
if ( any(is.na(imp1)) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_mice_std = NULL
}
if ( "MICE-ours" %in% all.methods ) {
imps_mice_ours = mice( di_ours,
maxit = p$imp_maxit,
m = p$imp_m )
# sanity check
imp1 = complete(imps_mice_ours, 1)
if ( any(is.na(imp1)) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_mice_ours = NULL
}
if ( "Am-std" %in% all.methods ) {
imps_am_std = amelia( as.data.frame(di_std),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_std$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_std = NULL
}
if ( "Am-ours" %in% all.methods ) {
imps_am_ours = amelia( as.data.frame(di_ours),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_ours$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_ours = NULL
}
# ~ Initialize Global Vars ------------------------------
# initialize rep.res st run_method_safe and other standalone estimation fns
#  will correctly recognize it as having 0 rows
rep.res = data.frame()
# ~ Fit Models ------------------------------
# ~~ Gold standard: No missing data ----
if ( "gold" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("gold"),
method.fn = function(x) fit_regression(form_string = gold_form_string,
model = p$model,
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest = paste(coef_of_interest, "1", sep = ""),
miss_method = "gold",
du = du,
imps = NULL),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ MICE-std ----
if ( "MICE-std" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("MICE-std"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_mice_std),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ MICE-ours ----
if ( "MICE-ours" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("MICE-ours"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_mice_ours),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ Am-std ----
if ( "Am-std" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("Am-std"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_am_std),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
# ~~ Am-ours ----
if ( "Am-ours" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("Am-ours"),
method.fn = function(x) fit_regression(form_string = form_string,
model = p$model,
coef_of_interest = coef_of_interest,
miss_method = "MI",
du = NULL,
imps = imps_am_ours),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
coef_of_interest
# coefficient of interest for gold-standard model
if ( coef_of_interest == "(Intercept)" ){
coef_of_interest_gold = "(Intercept)"
} else {
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest = paste(coef_of_interest, "1", sep = "")
}
coef_of_interest_gold
# ~ Fit Models ------------------------------
# ~~ Gold standard: No missing data ----
if ( "gold" %in% all.methods ) {
rep.res = run_method_safe(method.label = c("gold"),
method.fn = function(x) fit_regression(form_string = gold_form_string,
model = p$model,
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest = coef_of_interest_gold,
miss_method = "gold",
du = du,
imps = NULL),
.rep.res = rep.res )
}
if (run.local == TRUE) srr(rep.res)
imps_mice_std$predictorMatrix
imps_mice_ours$predictorMatrix
imps_am_ours$arguments
if ( "Am-ours" %in% all.methods ) {
imps_am_ours = amelia( as.data.frame(di_ours),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_ours$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_ours = NULL
}
head(di_ours)
cor(di_ours)
cor(di_ours, na.rm=TRUE)
cor(di_ours %>% !is.na(A))
cor(di_ours %>% filter(!is.na(A)))
di_ours %>% filter(!is.na(A))
?amelia
scen.params = tidyr::expand_grid(
rep.methods = "gold ; MICE-std ; Am-std ; MICE-ours ; Am-ours",
model = "OLS",
imp_m = 50,
imp_maxit = 100,
dag_name = c( "1C" ),
N = c(4000)
)
start.at = 1  # scen name to start at
scen.params$scen = start.at:( nrow(scen.params) + start.at - 1 )
sim.reps = 3  # reps to run in this iterate
# set the number of local cores
registerDoParallel(cores=8)
scen = 1
# data.frame(scen.params %>% filter(scen.name == scen))
# just to avoid errors in doParallel script below
jobname = "job_1"
i = 1
run.local=TRUE
# mimic Sherlock structure
if (run.local == TRUE) ( scens_to_run = scen.params$scen )
if (run.local == FALSE) ( scens_to_run = scen )  # from sbatch
# only print info for first sim rep for visual clarity
if ( i == 1 ) cat("\n\n~~~~~~~~~~~~~~~~ BEGIN SIM REP", i, "~~~~~~~~~~~~~~~~")
# results for just this simulation rep
if ( exists("rep.res") ) suppressWarnings( rm(rep.res) )
# extract simulation params for this scenario (row)
# exclude the column with the scenario name itself (col)
if ( verbose == TRUE ) {
cat("\n\n scen variable:\n")
print(scen)
cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) )
# ~ Simulate Dataset ------------------------------
sim_obj = sim_data(.p = p)
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
( form_string = as.character( sim_obj$form_string ) )
( gold_form_string = as.character( sim_obj$gold_form_string ) )
( beta = as.numeric(sim_obj$beta) )
( coef_of_interest = as.character( sim_obj$coef_of_interest ) )
head(du)
head(di_std)
# coefficient of interest for gold-standard model
if ( coef_of_interest == "(Intercept)" ){
coef_of_interest_gold = "(Intercept)"
} else {
# *this assumes coef_of_interest is always the factual variable
#  (e.g., A), so need to add "1" to use the variable
# that's in gold-standard model
coef_of_interest = paste(coef_of_interest, "1", sep = "")
}
# ~ Make Imputed Data ------------------------------
# details of how mice() implements pmm:
# ?mice.impute.pmm
if ( "MICE-std" %in% all.methods ) {
imps_mice_std = mice( di_std,
maxit = p$imp_maxit,
m = p$imp_m )
# sanity check
imp1 = complete(imps_mice_std, 1)
if ( any(is.na(imp1)) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_mice_std = NULL
}
imps_mice_ours$loggedEvents
imps_mice_ours$predictorMatrix
if ( "Am-std" %in% all.methods ) {
imps_am_std = amelia( as.data.frame(di_std),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_std$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_std = NULL
}
if ( "Am-ours" %in% all.methods ) {
imps_am_ours = amelia( as.data.frame(di_ours),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_ours$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_ours = NULL
}
head(di_ours)
di_ours2 = du %>% select(C, A, U1, RA)
head(di_ours2)
if ( "Am-ours" %in% all.methods ) {
imps_am_ours = amelia( as.data.frame(di_ours_2),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_ours$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_ours = NULL
}
if ( "Am-ours" %in% all.methods ) {
imps_am_ours = amelia( as.data.frame(di_ours2),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_ours$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_ours = NULL
}
toLoad = c("crayon",
"dplyr",
"foreach",
"doParallel",
"data.table",
"purrr",
"tidyr",
"tibble",
"testthat",
"Hmisc",
"stringr",
"mice",
"Amelia",
"sandwich")
for (pkg in toLoad) {
cat( paste("\nAbout to try loading package", pkg) )
tryCatch({
# eval below needed because library() will otherwise be confused
# https://www.mitchelloharawild.com/blog/loading-r-packages-in-a-loop/
eval( bquote( library( .(pkg) ) ) )
}, error = function(err) {
cat( paste("\n*** COULD NOT LOAD PACKAGE:", pkg) )
})
}
head(nhanes)
head(africa)
?rmvnorm
library(MASS)
# Number of variables
num_variables <- 10
# Generate correlation matrix with all correlations as 0.5
cor_matrix <- matrix(0.5, nrow = num_variables, ncol = num_variables)
diag(cor_matrix) <- 1  # Set diagonal elements to 1
# Generate mean vector
mu <- rep(0, num_variables)
# Generate samples from the multivariate normal distribution
n <- 100  # Number of samples
samples <- mvrnorm(n, mu, cor_matrix)
head(samples)
du = as.data.frame( mvrnorm(n, mu, cor_matrix) )
head(du)
# Generate samples from the multivariate normal distribution
N = 4000
du = as.data.frame( mvrnorm(N, mu, cor_matrix) )
cor(du)
# MCAR missingness
dm = du %>% mutate( across( 1:4, ~ ifelse( rbinom(n=1, size=1, prob=0.5), NA, .) ) )
head(dm)
?ampute
# MCAR missingness in first few variables only
n.with.missingness = 4
dm[ , 1:n.with.missingness ]
du = as.data.frame( mvrnorm(N, mu, cor_matrix) )
head(du)
dm = du
dm[ , 1:n.with.missingness ]
dm[ , 1:n.with.missingness ] = ampute( dm[ , 1:n.with.missingness ], mech = "MCAR")
ampute( dm[ , 1:n.with.missingness ], mech = "MCAR")
chunk = ampute( dm[ , 1:n.with.missingness ], mech = "MCAR")
chunk$amp
dm[ , 1:n.with.missingness ] = chunk$amp
head(dm)
fake = is.na(dm)
fake
# matrix of R indicators
R_mat = is.na(dm)
names(R_mat)
# matrix of R indicators
R_mat = as.data.frame( is.na(dm) )
head(R_mat)
paste("R", 1:10, sep = "")
names(R_mat) = paste("R", 1:10, sep = "")
head(R_mat)
# add indicators to dm
dm2 = bind_cols(dm, R_mat)
head(dm2)
imps = amelia( as.data.frame(dm2),
m=10)
# add only indicators that aren't constant
dm2 = bind_cols(dm, R_mat[ ,1:n.with.missingness])
# add indicators to dm
dm2 = bind_cols(dm, R_mat)
# add only indicators that aren't constant
dm3 = bind_cols(dm, R_mat[ ,1:n.with.missingness])
imps = amelia( as.data.frame(dm3), m=10)
du = as.data.frame( MASS::mvrnorm(N, mu, cor_matrix) )
?amelia
imps$theta
imps$covMatrices
imps$covMatrices[[1]]
# collinearity warning again
imps = amelia( as.data.frame(dm3), m=10)
# "An array with dimensions (p) by (p) by m where the first two dimensions hold the posterior modes of the covariance matrix of the complete data for each of the EM chains."
imps$covMatrices
head(dm3[5:ncol(dm3)])
# does this fix the collinearity?
imps = amelia( as.data.frame( dm3[5:ncol(dm3)] ), m=10)
# does this fix the collinearity?
# avoid having both proxy variable and its own missingness indicator
temp = dm3 %>% -select( c("V2", "V3", "V4", "R1") )
# does this fix the collinearity?
# avoid having both proxy variable and its own missingness indicator
temp = dm3 %>% -select( c(V2, V3, V4, R1) )
names(dm2)
# does this fix the collinearity?
# avoid having both proxy variable and its own missingness indicator
temp = dm2 %>% -select( c(V2, V3, V4, R1) )
# does this fix the collinearity?
# avoid having both proxy variable and its own missingness indicator
temp = dm2 %>% select( -c(V2, V3, V4, R1) )
head(dm2 )
# does this fix the collinearity?
# avoid having both proxy variable and its own missingness indicator
temp = dm2 %>% select( -c(V2, V3, V4, R1) )
select(dm2, -c(V2, V3, V4, R1) )
?select
# does this fix the collinearity?
# avoid having both proxy variable and its own missingness indicator
temp = dm2 %>% dplyr::select( -c(V2, V3, V4, R1) )
head(temp)
imps = amelia( as.data.frame( temp, m=10)
)
head(dm3)
# does this fix the collinearity?
# avoid having both proxy variable and its own missingness indicator
temp = dm3 %>% dplyr::select( -c(V2, V3, V4, R1) )
imps = amelia( as.data.frame( temp, m=10))
debug(amelia)
# collinearity warning again
imps = amelia( as.data.frame(dm3), m=10)
str(prepped)
undebug(amelia)
source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
# FOR LOCAL USE  ------------------------------
if ( run.local == TRUE ) {
lapply( toLoad,
require,
character.only = TRUE)
# helper fns
code.dir = here()
setwd(code.dir)
source("helper_IWN.R")
# for saving intermediate results
data.dir = str_replace( string = here(),
pattern = "Simulation code",
replacement = "Simulation results" )
# ~~ ********** Set Sim Params: Local Run -----------------------------
# FOR RUNNING 1 SCEN
scen.params = tidyr::expand_grid(
rep.methods = "gold ; MICE-std ; Am-std ; MICE-ours ; Am-ours",
model = "OLS",
imp_m = 50,
imp_maxit = 100,
dag_name = c( "1D" ),
N = c(4000)
)
# # FULL SET
# scen.params = tidyr::expand_grid(
#
#   # methods to run for each simulation rep
#   rep.methods = "gold-std ; CC-adj ; CC-unadj ; MI-adj ; MI-unadj",
#   model = "OLS",
#
#   # DAGs: Y_to_R_1, Y_to_R_2, comm_cause_1, comm_cause_2, comm_cause_3, mediation_1
#   dag_name = c( "Y_to_R_1", "Y_to_R_2",
#                 "comm_cause_1", "comm_cause_2", "comm_cause_3",
#                 "mediation_1" ),
#   N = c(100, 500, 5000, 10000),
#   # true OLS coefficient of A on Y
#   betaAY = c(1),
#   # OLS coeff of C on Y or vice versa
#   betaCY = c(1),
#   # OLS coef of A on C, if applicable
#   betaAC = c(1),
#   # logistic regression coef of C on R
#   betaCR = c(1),
#
#   # which var(s) should be missing?
#   # options: "c('A', 'Y', 'C'), c('A'), c('Y')"
#   missing_vars = c( "c('A', 'Y')", "c('Y')",  "c('A')" )  # quotation marks must be single inside double
# )
start.at = 1  # scen name to start at
scen.params$scen = start.at:( nrow(scen.params) + start.at - 1 )
sim.reps = 3  # reps to run in this iterate
# set the number of local cores
registerDoParallel(cores=8)
scen = 1
# data.frame(scen.params %>% filter(scen.name == scen))
# just to avoid errors in doParallel script below
jobname = "job_1"
i = 1
}
# RUN SIMULATION ------------------------------
# mimic Sherlock structure
if (run.local == TRUE) ( scens_to_run = scen.params$scen )
if (run.local == FALSE) ( scens_to_run = scen )  # from sbatch
# only print info for first sim rep for visual clarity
if ( i == 1 ) cat("\n\n~~~~~~~~~~~~~~~~ BEGIN SIM REP", i, "~~~~~~~~~~~~~~~~")
# results for just this simulation rep
if ( exists("rep.res") ) suppressWarnings( rm(rep.res) )
# extract simulation params for this scenario (row)
# exclude the column with the scenario name itself (col)
if ( verbose == TRUE ) {
cat("\n\n scen variable:\n")
print(scen)
cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) )
sim_obj = sim_data(.p = p)
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
( form_string = as.character( sim_obj$form_string ) )
( gold_form_string = as.character( sim_obj$gold_form_string ) )
( beta = as.numeric(sim_obj$beta) )
( coef_of_interest = as.character( sim_obj$coef_of_interest ) )
p$dag_name
source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
sim_obj = sim_data(.p = p)
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
( form_string = as.character( sim_obj$form_string ) )
( gold_form_string = as.character( sim_obj$gold_form_string ) )
( beta = as.numeric(sim_obj$beta) )
( coef_of_interest = as.character( sim_obj$coef_of_interest ) )
