source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
# because Sherlock 2.0 restores previous workspace
rm( list = ls() )
# are we running locally?
run.local = TRUE
# should we set scen params interactively on cluster?
# *if you accidently set this to TRUE and run via sbatches on cluster,
#   they will all run the same scenario!
interactive.cluster.run = FALSE
# should lots of output be printed for each sim rep?
verbose = TRUE
# ~~ Packages -----------------------------------------------
toLoad = c("crayon",
"dplyr",
"foreach",
"doParallel",
"data.table",
"purrr",
"tidyr",
"tibble",
"testthat",
"Hmisc",
"stringr",
"mice",
"Amelia",
"sandwich")
if ( run.local == TRUE | interactive.cluster.run == TRUE ) toLoad = c(toLoad, "here")
lapply( toLoad,
require,
character.only = TRUE)
# helper fns
code.dir = here()
setwd(code.dir)
source("helper_NMAR2.R")
# for saving intermediate results
data.dir = str_replace( string = here(),
pattern = "Code",
replacement = "Data" )
# FOR RUNNING 1 SCEN
scen.params = tidyr::expand_grid(
rep.methods = "MICE-std ; Am-std ; MICE-ours ; Am-ours",
model = "OLS",
dag_name = c( "1B" ),
N = c(4000)
)
start.at = 1  # scen name to start at
scen.params$scen = start.at:( nrow(scen.params) + start.at - 1 )
sim.reps = 3  # reps to run in this iterate
# set the number of local cores
registerDoParallel(cores=8)
scen = 1
# data.frame(scen.params %>% filter(scen.name == scen))
# just to avoid errors in doParallel script below
jobname = "job_1"
i = 1
# mimic Sherlock structure
if (run.local == TRUE) ( scens_to_run = scen.params$scen )
if (run.local == FALSE) ( scens_to_run = scen )  # from sbatch
scen.params
# only print info for first sim rep for visual clarity
if ( i == 1 ) cat("\n\n~~~~~~~~~~~~~~~~ BEGIN SIM REP", i, "~~~~~~~~~~~~~~~~")
# results for just this simulation rep
if ( exists("rep.res") ) suppressWarnings( rm(rep.res) )
# extract simulation params for this scenario (row)
# exclude the column with the scenario name itself (col)
if ( verbose == TRUE ) {
cat("\n\n scen variable:\n")
print(scen)
cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
p
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) )
# ~ Simulate Dataset ------------------------------
sim_obj = sim_data(.p = p)
source("~/Dropbox/Personal computer/Independent studies/2023/*IWN (Imputation without nightMARs)/Simulation code/helper_IWN.R")
sim_obj = sim_data(.p = p)
sim_obj
# FOR LOCAL USE  ------------------------------
if ( run.local == TRUE ) {
lapply( toLoad,
require,
character.only = TRUE)
# helper fns
code.dir = here()
setwd(code.dir)
source("helper_IWN.R")
# for saving intermediate results
data.dir = str_replace( string = here(),
pattern = "Code",
replacement = "Data" )
# ~~ ********** Set Sim Params: Local Run -----------------------------
# FOR RUNNING 1 SCEN
scen.params = tidyr::expand_grid(
rep.methods = "MICE-std ; Am-std ; MICE-ours ; Am-ours",
model = "OLS",
imp_m = 50,
imp_maxit = 100,
dag_name = c( "1B" ),
N = c(4000)
)
# # FULL SET
# scen.params = tidyr::expand_grid(
#
#   # methods to run for each simulation rep
#   rep.methods = "gold-std ; CC-adj ; CC-unadj ; MI-adj ; MI-unadj",
#   model = "OLS",
#
#   # DAGs: Y_to_R_1, Y_to_R_2, comm_cause_1, comm_cause_2, comm_cause_3, mediation_1
#   dag_name = c( "Y_to_R_1", "Y_to_R_2",
#                 "comm_cause_1", "comm_cause_2", "comm_cause_3",
#                 "mediation_1" ),
#   N = c(100, 500, 5000, 10000),
#   # true OLS coefficient of A on Y
#   betaAY = c(1),
#   # OLS coeff of C on Y or vice versa
#   betaCY = c(1),
#   # OLS coef of A on C, if applicable
#   betaAC = c(1),
#   # logistic regression coef of C on R
#   betaCR = c(1),
#
#   # which var(s) should be missing?
#   # options: "c('A', 'Y', 'C'), c('A'), c('Y')"
#   missing_vars = c( "c('A', 'Y')", "c('Y')",  "c('A')" )  # quotation marks must be single inside double
# )
start.at = 1  # scen name to start at
scen.params$scen = start.at:( nrow(scen.params) + start.at - 1 )
sim.reps = 3  # reps to run in this iterate
# set the number of local cores
registerDoParallel(cores=8)
scen = 1
# data.frame(scen.params %>% filter(scen.name == scen))
# just to avoid errors in doParallel script below
jobname = "job_1"
i = 1
}
du = sim_obj$du
di_std = sim_obj$di_std
di_ours = sim_obj$di_ours
imps = mice( di_std,
maxit = .p$maxit,
m = .p$imp_m )
# only print info for first sim rep for visual clarity
if ( i == 1 ) cat("\n\n~~~~~~~~~~~~~~~~ BEGIN SIM REP", i, "~~~~~~~~~~~~~~~~")
# results for just this simulation rep
if ( exists("rep.res") ) suppressWarnings( rm(rep.res) )
# extract simulation params for this scenario (row)
# exclude the column with the scenario name itself (col)
if ( verbose == TRUE ) {
cat("\n\n scen variable:\n")
print(scen)
cat("\n\n scen.params again:\n")
print(scen.params)
}
p = scen.params[ scen.params$scen == scen, names(scen.params) != "scen"]
# show beginning of dataset
if ( i == 1 & verbose == TRUE) cat("\n\nDIM AND HEAD OF P (SINGLE ROW OF SCEN.PARAMS):\n")
# parse methods string
all.methods = unlist( strsplit( x = p$rep.methods,
split = " ; " ) )
imps = mice( di_std,
maxit = .p$maxit,
m = .p$imp_m )
imps = mice( di_std,
maxit = p$maxit,
m = p$imp_m )
?mice
p
p$imp_maxit
imps = mice( di_std,
maxit = p$imp_maxit,
m = p$imp_m )
# sanity check
imp1 = complete(imps, 1)
if ( any(is.na(imp1)) ) stop("MI left NAs in dataset - what a butt")
imps_mice_std = imps
rm(imps)
imps_mice_ours = mice( di_ours,
maxit = p$imp_maxit,
m = p$imp_m )
# sanity check
imp1 = complete(imps_mice_ours, 1)
if ( any(is.na(imp1)) ) stop("MI left NAs in dataset - what a butt")
if ( "Am-std" %in% all.methods ) {
imps_am_std = amelia( as.data.frame(di_std),
m=m)
# check for problems
if ( any(is.na((imps_am_std$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_std = NULL
}
imps_am_std = amelia( as.data.frame(di_std),
m=p$m)
imps_am_std = amelia( as.data.frame(di_std),
m=p$imps_m)
p$imps_m
imps_am_std = amelia( as.data.frame(di_std),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_std$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
if ( "Am-ours" %in% all.methods ) {
imps_am_ours = amelia( as.data.frame(di_ours),
m=p$imp_m)
# check for problems
if ( any(is.na((imps_am_ours$imputations$imp1))) ) stop("MI left NAs in dataset - what a butt")
} else {
imps_am_ours = NULL
}
